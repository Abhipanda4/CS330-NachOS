1. SysCall_GetReg: The functions machine->ReadRegister and machine->WriteRegister were used to first read register 4, get the target register number, read the target register, and put the value in the return register, register 2.

2.SysCall_GetPA: The function machine->translate is used. The size field is set to 0, since the address is guaranteed to be a valid one. The write is also set to zero. The return value is examined for any exceptions. In the case any are found, register 2 gets set to -1, else the physical address.
The translate function itself, based on whether a Page table or a TLB is being used, tries and translates the address while carefully checking for any errors such as out of bounds error.

3. SysCall_GetPID: A static variable was assigned in the NachOSThread class, that starts with the value 1. This value is assigned to any thread being created in the constructor, and is then incremented. A getter function is also defined in the NachOSThread class, which is called during the handling of the syscall, and the value put in register 2.
During this time, a decentralized proc table was also created, in order to handle the children of each process, for use in future syscalls. Each thread thus also has a list of all its direct children, and pointers to them, along with their status and their PID in the form of a linked list of structures defined in the thread class, with a static head of the list called procHead. The decision for the structure to be decentralized was made keeping in mind the decentralized nature of the already existing process information storage.

4. SysCall_GetPPID: During creation of a process, in the constructor of the tread class, the ppid value is set equal to the pid of the creator, its parent. A getter function is defined to expose this, which is called suring the handling of the syscall. The first process has ppid -1, since NachOS does not have a init process.

5. SysCall_GetTime: Time is maintained by an object of the Statistics class in a public variable totalTicks, which is used to handle this syscall.

	6. SysCall_Sleep: The syscall handler takes as input the number of ticks to sleep for. If this is 0, this is equivalent to SysCall_Yield(see below). The thread class provides functionality to put a process to sleep, and the scheduler provides the functionality to add it to the readyqueue, which are used. The only thing left to handle was waking up the process at the right time.
A queue of processes is maintained statically by the NachOSThread class, of all the processes that are asleep. This is maintained in increasing order of the time when they have to be woken up(ticks at which they need to be woken, and NOT ticks that was passed to their sleep call). The only role of the syscall handler is to add the current process to this queue, which is done via a static function, and pass to the function the time at which the process needs to be woken. The actual waking up is handled using the timerInterrupt that is generated by NachOS every few ticks, by the system. This interrupt is handled using the TimerInterruptHandler function, in which code is added that checks all the processes in the queue against the current time, decides if they have to be woken, and if so, adds them to the ready queue. (due to the ascending order of storage, all processes do not need to be checked)

	7. SysCall_Yield: The syscall is handled using the Yield_CPU function provided by the NachOSThread class. This function switches off interrupts, checks if another thread is ready to be scheduled, if not, waits for another thread to be ready to be scheduled, schedules that thread, then adds the current thread to the ready queue. It finally switches the interrupts back on before returning.

	8. SysCall_Fork: Here, the following steps are done:
	i) The program counter is increased, so that when the child copies the context, it starts at the next instruction instead of repeatedly forking
	ii) A new thread object is created. Initally, all its object vairables except pid, ppid and name are set to null.
	iii) A New ProcessAddressSpace object is created. Further, memory is assgined for the new thread equal to the memory taken up by the parent, and the page table is set up. Here, the memory assignment is trivial, and the next n pages of the physical memory are assgined, and the virtual pages map to those in increasing order. Memory from killed threads is not reused.
	iv) The new physical memory that is assigned is filled by copying the data from the parents physical memory to it.
	v) The current registers, which are the parents, and copied over to the child, using the SaveUserRegisters function, which copies the current registers to the threads user registers. Before this, the return register is set to 0, for the child, and after this, it is set to the PID of the child, for the parent.
	vi) Finally, the ThreadFork function is called. This function does two things. It first allocates and sets up the kernel stack, and assigns all related variables such as the stack and the stack top, in an implementation specific manner. It also sets up the machine state for the process, which includes what should be executed initially when the thread is scheduled. This is set to a function defined in exception.cc called PostSwitch, that handles everything an ordinary(not new) thread does immedietly after it is scheduled, which includes deleted any finished threads.

	9. Syscall_Exec: The executable filename is read from the memory address stored in register 4. Then a procedure similar to LaunchUserProcess function in userprog/progtest.cc is carried out for executing the executable binary. The constructor of ProcessAddressSpace is also changed suitably to accomodate the offset for having multiple threads running.

	10. SysCall_Join: Firstly the existence of a child with the specified PID is checked. If not found, the process returns -1 and PC is incremented so that proceess could continue execution. If the child is found, the following 2 cases are handled:
	i) if child had already exited, the process simply resumes execution.
	ii) if child is still alive, the thread is put to sleep. A flag isParentWaiting is set to true in the corresponding child. The child is given the responsibility of waking up the parent upon exiting.
	The status of the child is found through another boolean flag, isAlive which is set to true on initialization and chyanged to false on exiting.
	Also, it is possible that the parent is woken up by one of its multiple children. Hence, it is again checked whether the thread that woke up the parent is same as that who called the join syscall. Once the child with the proper PID returns, its exitstatus is written to register 2.

	11. SysCall_Exit: Firstly,  if the number of live threads is 1, the machine is halted. The number of live threads is inferred from a new variable totalActiveThreads declared in NachOSThread class. This is incremented in constructor of NachOSThread and decremented in the Destructor. If the thread has an alive parent, it is checked if the parent was waiting for the child to complete execution. If so, the parent is moved to ready queue via the MoveThreadToReadyQueue function defined in Scheduler class. Then the isAlive flag is set to false for the child. The parent of all the children of the current(going to exit) thread is made NULL. Finally, FinishThread function is called to terminate the thread.

	12. Syscall_NumInstr: Each NachOSThread class stores a variable numInstr, which is incremented every time the function OneInstruction is called in mipssim.cc. The final value is returned.
